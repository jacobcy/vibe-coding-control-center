# Vibe Coding 团队工程范式 

`Plan` → `Spec` → `Execution Plan` → `Test` → `Code` → `AI Audit Review`

**定位**：适用于所有生产分支（main / release）。
**核心理念**：人类不写代码，甚至不读代码，但必须死守“认知、规范与主权”。AI 负责实现、测试与审计，但必须被机械约束与流程卡口死死锁住。

⸻

### 0. 总原则（宪法层）
1. **立法与行政分离**：人类主导立法（Plan/Spec），AI 负责行政（执行与测试），CI 与独立 AI 负责执法（熔断与审计）。
2. **测试先行，机械卡口**：先测试，后代码。任何阶段不满足条件，CI 直接拒绝，不允许人情绕过。
3. **隔离探索与生产**：允许在沙盒（Spike分支）中不受限地与 AI 自由对话探索；但一旦进入生产分支，**所有沙盒代码必须抛弃**，严格按本范式重新走线。
4. **人类只对“报告”负责，不对“源码”负责**：放弃肉眼 review 机器代码的执念，用系统和报告来治理系统。

⸻

### 1) 认知层 PRD（人类主导：定目标）
PRD 是“我们要解决什么问题”，绝不是实现方案。

**必须输出（文本即可）：**
* **业务目标**：要实现的核心能力是什么。
* **绝对边界**：不做什么（明确列出拒绝项，防止 AI 过度设计与发散）。
* **核心数据流**：输入 → 处理 → 输出 的最小业务闭环。
* **成功判据**：上线后如何判断成功或失败。

**🚫 红线：**
* PRD 不完整，禁止进入 Spec。
* 禁止AI过度设计与发散（例如：以工业级标准规划个人脚本）

⸻

### 2) 规范层 Spec（人类主导+AI刺客找茬：定法律）
Spec 是“系统行为法律文本”，用于彻底锁死 AI 后续的发挥空间。

**必须包含：**
* **接口契约**：输入/输出/错误（强推 Schema/Interface/Proto）。
* **核心不变量（Invariants）**：在任何情况下都必须绝对成立的业务规则。
* **边界与异常行为**：极限输入、空值、脏数据、超时、幂等、重试机制。
* **非功能约束**：性能上限、可观测性要求。

**🤖 引入“AI 架构刺客”机制：**
* 在 Spec 锁定前，必须由另一个独立的 AI Agent 进行“逆向提问（Devil's Advocate）”，专门挑刺（如：“如果网络熔断怎么保证幂等？”）。人类补充完善后，方可锁定 Spec。

**🚫 红线：**
* Spec 一旦锁定，后续阶段**绝对禁止**“为了通过测试/实现方便”而反向修改 Spec。发现不通，只能作废流程，回退到 Plan/Spec 阶段重新立法。

⸻

### 3) 执行方案 Execution Plan（AI 产出，人类审批：定路径）
Execution Plan 是“如何落地”，必须防幻觉、可审计、可回滚。

**必须输出：**
* **上下文圈定（Context Scoping）**：AI 必须明确列出“我需要读取哪几个文件作为上下文”。（防止乱喂代码库导致 AI 幻觉和胡乱修改）。
* **任务拆分清单**：具体到模块/文件/接口的改动点。
* **风险对策与回滚**：并发/限流策略、数据迁移步骤、失败回滚条件。

**🚫 红线：**
* 人类必须审查“上下文圈定”是否合理。超范围的上下文必须被剔除。
* PRD/Spec 与 Execution Plan 出现逻辑不一致，直接打回重做。

⸻

### 4) 测试 Test（AI 编写，Spec 为唯一真源：锁行为）
测试不是 AI 顺手写的“自证工具”，而是对 Spec 的强制可执行化。

**强制规则：**
* **真理唯一**：测试的输入与断言，必须 100% 来源于 Spec 的契约与不变量。
* **全面覆盖**：必须包含 Normal Path、Edge Cases、Error Flow。
* **TDD 顺序锁死**：测试必须先在 CI 中运行失败（Red），才允许触发实现代码（Code）的生成。

**🤖 引入“幻觉死循环熔断”：**
* 如果 AI 在后续 Code 阶段，**连续 3 次** 修改代码都无法让测试变绿（Green），**系统强制中断**。禁止 AI 继续盲目试错修改，必须由人类介入排查是 Spec 有逻辑死结，还是底层架构有历史包袱。

**🚫 红线：**
* 严禁为了“让测试变绿”而去弱化断言、删减边界用例。

⸻

### 5) 代码 Code（AI 实现，机械防线锁死：填实现）
AI 负责填空，但必须戴着沉重的镣铐跳舞。解释权归 CI，不归人。

**5.1 AST 级约束（架构防腐）**
* 禁止未经审批引入第三方新依赖。
* 禁止跨层调用（例如 Domain 层绝对禁止 import Infra 层或 UI 层）。
* 核心业务域代码中，禁止混入任何 IO/网络/数据库层面的副作用调用。

**5.2 复杂度熔断（反大泥球机制）**
* 单函数长度上限（如 40 行）、圈复杂度上限（如 10）。
* 复杂度超标，CI 自动阻断，要求 AI 进行“拆分重构”后重新提交。
* **“赶进度”绝不是绕过熔断的理由。**

⸻

### 6) AI 审计与人类决议（AI Audit Review：守主权）
人类不再逐行 Review AI 写的代码（人类看不懂也不该看毫无灵魂的机器代码），而是**由独立的 AI 审计官（AI Auditor）生成标准化报告，人类进行最终的“主权确认”。**

**AI 审计官必须生成的《可读性评审报告》包含：**
* 🟢/🔴 **目标对齐**：代码是否偷换了 Plan 的概念？
* 🟢/🔴 **规范遵守**：Spec 中的不变量是否被 100% 测试覆盖且通过？
* 🟢/🔴 **路径一致**：是否严格按照 Execution Plan 的步骤执行，有无偷工减料？
* 🟢/🔴 **架构纯洁**：AST 与复杂度检查是否全绿？核心域是否被污染？

**人类的职责：**
* 拿着这份 AI 生成的评审报告，核对“必审清单”。
* 重点审查是否存在“AI 越权”（比如隐蔽地弱化了某个边界测试、绕过了某个异常处理）。
* 只要报告证明一切在控制之中 -> **Approve (签署决议)**。

**🚫 红线：**
* 报告中任何一项亮红灯：一律拒绝合并。
* 如果发现 AI 审计官和 AI 编码员“串通作恶”（审计报告撒谎），视为重大生产事故，需升级审计 Prompt 或更换审计大模型。

⸻

### 📜 最终铁律（一句话版）

**PRD 定目标，Spec 定法律，Execution Plan 圈范围，Test 锁行为，Code 填实现，AI Audit 呈报告，Human 签决议。**
*(并且：AST 管控依赖边界，复杂度熔断控制腐化，3次重试失败强制熔断打断 AI 幻觉！)*