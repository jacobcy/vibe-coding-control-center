Cognition First (认知优先)

> **核心命题**: 认知是最昂贵的资产，代码是认知的副产品。

传统软件工程假设代码是最昂贵的资产，所以建立了大量保护代码的规范 — code review、lint、test coverage、refactor rather than rewrite。Vibe Coding 的现实完全不同：一旦认知建立，代码可以在一小时内重现。

### 2.1 The Cognition-Code Inversion (认知-代码倒置)

| | 传统工程 | Vibe Coding |
|---|---|---|
| 最贵的资产 | 代码 | 认知 |
| 原型阶段的目的 | 产出可迭代的最小产品 | 产出正确的心智模型 |
| 规范的作用 | 保护代码质量 | 保护认知成果 |
| "重来"的成本 | 高（人月级） | 低（小时级） |
| 瘦身 vs 重建 | 瘦身通常更经济 | 重建通常更经济 |

### 2.2 Two-Phase Norm Model (双阶段规范模型)

开发不是线性过程，而是两个本质不同的阶段：

**探索期（认知未建立）**:
- 代码是草稿纸，写了就可以扔
- 强规范在此阶段**有害** — 阻碍试错速度，拖慢认知形成
- 唯一的硬规范：不污染 main，用 worktree 隔离
- 目标：通过反复实验，理解问题本质

**收敛期（认知已建立）**:
- 目标明确，知道该做什么、不该做什么
- 启动强规范 — scope gate、LOC ceiling、PR compliance
- 防止膨胀复发，保护已建立的认知
- 代码质量要求在此阶段才有意义

### 2.3 Phase Transition (阶段切换)

切换触发器 = **架构审计**。

审计不是惩罚，是**认知确认仪式**：
- 你现在知道问题是什么了吗？→ 知道了 → 上强规范，进入收敛期
- 还不确定？→ 继续探索，弱规范保持
- 项目膨胀超过 5 倍基线？→ 提取认知资产，推倒重来，不要瘦身

### 2.4 Implications (推论)

1. **原型代码无需羞耻**: 探索期的混乱代码是正常产出。它的价值不在代码本身，而在它教会了你什么。
2. **重建优于修补**: 当膨胀超过 5x，理解 14,000 行垃圾的成本远大于写 800 行新代码的成本。
3. **规范随认知成熟度升级**: 不随代码量增长，不随项目年龄增长。一个3年老项目如果认知仍在探索期，强规范依然不适用。
4. **审计产出认知，不是裁决**: 审计报告的真正价值是资产提取清单和认知确认，不是代码评分。
5. **沉没成本为零**: 被丢弃的原型代码的唯一遗产是开发者脑中的心智模型。